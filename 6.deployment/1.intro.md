---
reviewed: 2023-07-28 17:25:38
title: Deployment intro
naviTitle: Intro
navigation.excerpt: Git push to deploy and some gotchas
lead: Code deployment is a multi-step process to deliver code from your local computer to a web server in a reliable and automated fashion.
nextNav: true
structureNav: true
head:
  meta:
    - name: 'keywords'
      content: 'grunt, gulp, browserify, vite, webpack, svn, git, coding, CI/CD, cloud, vcs, add-on, version control'
---


## The outline

In regard of deployment, Git is not only used as a version control system, but also as a transport layer to copy over the latest code changes. A typical code deployment on fortrabbit consists of the following deployment pipeline:

```raw
1 Local    2 Git provider    3 fortrabbit          4 app environment 
┌─────┐    ┌────────────┐    ┌───────────────┐     ┌──────────────┐
│ Git ├────▶  Git repo  ├────▶  Build steps  ├─────▶   web space  │
└─────┘    └────────────┘    └───────────────┘     └──────────────┘
```

1. You work on your local Git repo
2. You push code changes to the git provider (GitHub)
3. The 'fortrabbit GitHub app' triggers a deployment with build steps
4. The build is getting distributed into the web space of the [app environment](/10.objects/2.app-environment.md)

## Code VS content

"**Code goes up, content comes down**" is the basic principle for most live websites. While development is usually happening in the local development environment, content updates are often done in the production environment directly, for instance when an editor is adding a new blog post. In many software systems, code and content are separated and do not interfere. A classical PHP project consists of these blocks:

| What                          | Deployment | Alternative   |
| ----------------------------- | ---------: | ------------: |
| Code and dependencies         | Yes        | -             |
| Database contents             | No         | dump          |
| Image uploads and other files | No         | rsync         |

In addition to deployment, [direct code access](/7.code-access/1.intro.md) via [SSH](/7.code-access/3.ssh.md) and [SFTP](/7.code-access/4.sftp.md) is also available. This is useful to sync contents and to debug issues.

## What the web storage contains

Please keep in mind, that the Git repo is not a one to one representation of the web storage. After you Git push, first the Git repo will be updated, then changes will be synchronized (overwrite but not delete) to the web storage. So the web storage contains:

1. The latest Git changes synced in
2. Artifacts from build steps
3. Changes done by [direct code access](/7.code-access/1.intro.md)
4. Runtime data like uploads, assets, logs, template fragments …

## Git works only one way

**Git is a one way street here and the only way is up.** You can not `pull` the changes, which are made via SSH or SFTP, from the web storage back into your Git repo. So you can not upload something via SFTP and clone it down later via Git. While this might looks odd at first: this design keeps your Git repo clean of temporary, binary and other blob data. The diagram above visualizes this. Use Git only for code deployment, not to manage all of your Apps runtime data. Separate code - managed in Git - from content - managed via SSH/SFTP.

## Deployment strategy

The result of the changes received by git push and the build steps execution is called a deploy package - a temporary file set. This will be put into the web storage of the app environment somehow. You can change the deployment synchronization strategy setting with the dashboard. Here are the options:

### No delete deployment strategy

The default strategy applied for deployment package synchronization is overwrite but not delete:

* Newer files will replace older files on the web storage
* New files will be created on the web storage
* **Files not present in the deploy package but on the web storage will not be touched**

This strategy fit's most use cases, since no runtime data, like uploads, transforms, caches template fragments and other content will get deleted. This however can result in some weird edge case side effects.

### Full replace deployment strategy

Another deployment strategy is to create an exact copy of the current deploy package in the web space. That means, all files in the web space will be deleted first and replaced by the contents of the deploy package. This is sometimes called atomic or immutable deployment. It's related to 12-factor design and ephemeral web storage where the web application should not write anything to disk. In theory it's great, since it would allow you to rollback to any previous state easily. Reality is more messy in our experience, this does not play well with many PHP based web applications.

In addition to the full replace strategy you can set certain sustained folders that will be excluded from the full replacement. Used together, full replacement strategy with sustained folders is the recommended way to deploy.

## Not all applications work well with Git

Git deployment is great when the skeleton has clean folder structure with exclude patterns and [Composer](/14.tips/composer.md) support. [Laravel](/2.laravel/1.setup.md) and [Symfony](/5.guides/8.symfony.md) are poster-child-level for good Git support. [WordPress](/5.guides/5.wordpress.md) and other CMS are not Git compatible, out-of-the-box. [Craft](/3.craft/1.setup.md) works well with Git and Composer.
