---
reviewed:         2023-07-10 10:35:35
title:            GitHub
navitTitle:       GitHub integration
excerpt:          Connect your repos
lead:             Learn how to connect the most popular Git-as-a-service provider with your fortrabbit workflow.
sidebar:          github

keywords:
  - git-hub
  - integrations
  - gitlab
  - bitbucket
  - coding
  - CI/CD
  - cloud
  - vcs
  - add-on
  - version control
---

## Git ready

We assume that you have: [Git installed](3.guides/2.craft/more/git.md) locally and know the basics. We further assume that you have your SSH keys installed.

## Advanced usage

Still reading? Dig deeper!

### Git works only one way

**Git is a one way street here and the only way is up.** You can not `pull` the changes, which are made via SSH or SFTP, from the web storage back into your Git repo. So you can not upload something via SFTP and clone it down later via Git. While this might looks odd at first: this design keeps your Git repo clean of temporary, binary and other blob data. The diagram above visualizes this. Use Git only for code deployment, not to manage all of your Apps runtime data. Separate code - managed in Git - from content - managed via SSH/SFTP.

### Git push overwrite but not deletes

When you push new changes via Git to your App Composer will be executed. In addition, user defined scripts (either specified via [deployment file](/deployment-file-v2) or [Composer scripts](https://getcomposer.org/doc/articles/scripts.md)) might also be executed. Resulting of the push and the executions, a temporary file set is generated and subsequently synchronized to your App's web storage. So, when accessing your App via SSH/SFTP, the web storage can contain files which are not in Git.

The strategy applied in the synchronization is:

* Files existing in the temporary file set and existing on the web storage will be overwritten
* Files existing in the temporary file set but not existing on the web storage will be created
* Files not existing in the temporary file set but existing on the web storage will not be touched

### Not all applications work well with Git

Git deployment is great when your App skeleton has clean folder structure with exclude patterns and [Composer](/composer) support. [Laravel](/install-laravel) and [Symfony](/install-symfony) are poster-child-level for good Git support. [WordPress](/install-wordpress-uni) and other CMS are not Git compatible, out-of-the-box. [Craft](/craft-deploy-git) works well with Git and Composer.

### Git deployment VS direct access 

Universal Apps have persistent storage, which you can access via [SSH](ssh-uni) or [SFTP](sftp-uni). It further means that runtime data, like user uploads, are persistent and *will not be removed* upon Git push.

To make sure nothing is deleted, all git deployments to Universal Apps follow an **overwrite but not delete** strategy which is thoroughly explained in the [deployment methods article](deployment-methods-uni#toc-git-push-overwrite-but-not-deletes).

### Behind the scenes

```nohighlight
┌─────────┐             ┌──────────┐             ┌───────────┐
│         │             │          │             │           │
│   You   ├──Git push───▶ Git repo ├───deploy────▶    App    │
│         │             │          │             │           │
└─────────┘             └──────────┘             └───────────┘
```

Your `git push` updates the Git remote on fortrabbit and triggers the build of a new release package. This new release package will then be distributed to all the Nodes your App runs on. All files on the Nodes will then be replaced by the ones contained in the release package. Check out [this video](deployment-architecture-video) to understand the flow.

### The branch name that counts

TODO!

### Deployment file

Fine tune deployment configurations with the `fortrabbit.yml` deployment file: control the way Composer runs, define pre- & post-deploy scripts and more. You can find a full example [here](deployment-file-v2).

### Large Git repos

A bloated Git repository slows down deployment. You might even hit our limits. In most cases the repo can and should be much smaller.

#### Large files

We don't actively enforce a single file limit, but you should not put big binary files (> 2 MB) into your Git repo.

In general we also advise not to put assets and most importantly images or even videos in Git. Some images that belong to your website layout, like your company logo (a small SVG) are ok. But when you have a lot of images in Git, odds are that this is bad practice.

For almost all cases, your uploaded content images (`.jpg`, `.png`, `.gif`) do not belong in Git. Remember that the Git repo and the web-space are different things here at fortrabbit, [Git is a one-way street here](/deployment-methods-uni#toc-git-works-only-one-way). The next user upload will not be in Git anyways. It's a good practice to **separate code from content** for many reasons. So we advise to deploy user uploads, static assets and other runtime data separate from the core code deployment done with Git. With Universal Stack you can use SFTP/SSH or rsync for this. With the Professional Stack you'll manage those assets on the [Object Storage](/object-storage) anyways.

#### The hidden .git folder

Git never forgets. It can bring back any content from any file, even deleted ones. To do so, it stores all the stuff in the hidden `.git` folder at the top level of the repo. Over time that file can get big too. It can also contain unreachable blobs and other stuff you are not aware of. Depending on the situation, there are many ways to clean this up: delete files of a certain type, delete the history before a certain date, or even start again from the current state.

### Deployment release package

The release package is a gzipped archive which contains: the App's Git repository + vendor folder + all files generated by pre- or post-deployment scripts. In short: compressed size of ``~/htdocs``.

To keep deployment fast for everyone the size of the release package is [limited](http://www.fortrabbit.com/specs#limits). You can find out the release package size locally by packaging the local copy of your App, including the `vendor` folder and anything else generated by your build scripts:

```bash
tar -zcf my-project.tar.gz {{app-name}}
ls -lh {{app-name}}.tar.gz
```