---
reviewed: 2023-07-08 13:45:46
title:    Workers
excerpt:  Background processing for resource-hungry jobs
lead:     Offshore long running and compute intensive tasks with background jobs.
sidebar:  workers
structureNav: true
---

<!-- TODO: Review by Infra -->

## About workers

Don't let your users suffer when your website is busy. Generating caches, sending transactional mails, communicating with remote APIs, RSS feed reading and parsing, image processing, uploading data to an external storage — these tasks are taking long to execute and slow down your website.

```raw
┌─────────┐                        ┌───────────────────┐      ┌────────┐
│ visitor │ ◀─ Request/response ─▶ │  app environment  │ ◀──▶ │ worker │
└─────────┘                        └───────────────────┘      └────────┘
```

You want dedicated back-end PHP processes that are totally isolated from your web front-end. Use the worker component to offload those long running tasks. Background jobs are a key to resilient web applications. They transfer time and compute intensive tasks from the front-end web layer to a background process that lives outside the user request/response life-cycle. Typical examples use cases are transforming images are sending mails in the background.

## Booking

The worker is an optional component that can be booked and scaled from an [app environment](/10.objects/2.app-environment.md) in the [dashboard](/11.concepts/dashboard.md). The scaling increases in available RAM and number of jobs. Consider using a background job for any web request that runs longer than 500ms. The memory limit is for all jobs combined. Resources needed for each application can vary largely, depending on what each particular job is doing.

:DashboardLink{title="Book workers for {{app-env-slug}}" path="/environments/{{app-env-slug}}/components/workers"}

## Using workers

Once you have booked the worker component, an additional worker settings page is available in the dashboard. Here you can add, remove, start, stop and edit jobs.

* **Name**: A unique name, identifier for Dashboard, logs & statistics
* **Command**: PHP command to be executed, for example `artisan queue:listen -v` or `path/to/my-script.php`
* **Termination signal**: Unix termination signal to restart job, just use default when unsure
* **Termination timeout**: Grace time after which the job will be "hard killed" (`SIGKILL`), if shutdown termination signal has been sent
* **Status**: You can temporary disable jobs (start/stop)

### Metrics

There are two ways to monitor your worker: statistics (see [below](#job-statistics)) via SSH and metrics within the App metrics overview in the Dashboard. The last will inform you about:

**Swap Usage**: The amount of swapped memory your Worker jobs are causing. Any swap greater than zero indicates that you should upgrade your Worker component

**Memory Usage**: The amount of memory your Worker jobs are using. Can be higher than the total sum of memory of all jobs, because it includes Linux VFS cache. Primarily interesting in terms of change over time: is there something growing out of bounds?

**Cron Job runs**: Total amount of Cron Job executions over time.

**Cron Job fails**: Total amount of failed Cron Jobs over time. Any value greater than zero is a good reason to look into the Worker logs.

**Nonstop (re)starts**: Total amount of (re)starts of jobs. Mind that each git push triggers a restart. If restarts occur outside of deployment, then the jobs have been dying and were restarted. A good cause to look into the logs.

## Logging

You can access the job output of your Worker. Both STDOUT and STDERR generated by any job are logged:

First comes the formatted time ([RFC 3339](https://tools.ietf.org/html/rfc3339)), followed by the log level, the name of the job and finally the message which has been written. See our [logging article](/11.concepts/logs.md) for more.

## Restart after code update

This happens automatically. Whenever you push a new code update via git deployment, jobs will be shutdown and started anew.

### Statistic considerations

* The total (max) memory amount of all jobs should be below the memory limit of the plan.
* Exits of jobs should be looked into. Usually Nonstop run continuously.

## Graceful shutdown

Say your job does really long running stuff or is very busy - meaning that it's likely that it is currently working when you push new code, which leads to a restart of the job. In this case, you might not want to abort (restart) it. The solution is to utilize Unix signal handling to write a shutdown handler. For this you can use the automatically available [PCNTL](http://php.net/manual/en/book.pcntl.php) extension.

The most simplistic PHP script for a job is a while loop:

```php
while (true) {
  do_something();
  sleep(5);
}
```

To make sure that `do_something()` is never aborted, you can extend the script like so:

```php
declare(ticks=1);

$shutdown = false;
pcntl_signal(SIGTERM, function($signo) use (&$shutdown) {
    error_log("Received shutdown signal");
    $shutdown = true;
});

while (true) {
  do_something();
  foreach (range(1, 5) as $num) {
    if ($shutdown) {
      error_log("Shutting down safely");
      exit(0);
    }
    sleep(1);
  }
}
```

## Do not detach

If you don't know what that is: never mind. If you do know: don't detach. To guarantee that we can monitor jobs correctly they need to run with-under the parent processes which started them. All detached processes will be killed.
