---
reviewed: 2025-06-19 17:30:14
title: Key-value store
navigation.excerpt: Database, cache, queue message broker
siblings: Components
lead: In-memory data store based on Valkey.
wip: true
sidebar: key-value-store
---

The key-value store is a Redis-compatible versatile open source software to be used as in-memory data structure store, key-value database, cache or even queue message broker.

:BlockLink{title="Book key-value store" path="/environments/{{app-env-id}}/settings/components#key-value-store"}

The key-value component is based on Valkey - a high-performance, open-source key-value data store that evolved from Redis. It supports various data structures including strings, hashes, lists, sets, and sorted sets. With sub-millisecond latency and the ability to handle millions of operations per second, it's perfect for modern web applications that need fast data access.

## Use cases

- **Caching**: Store frequently accessed data in memory to reduce database load and improve response times.
- **Session storage**: Keep user sessions in memory for fast access across multiple servers.
- **Real-time analytics**: Track page views, user interactions, and other metrics in real-time.
- **Message queuing**: Implement pub/sub patterns for real-time features like notifications or chat.
- **Rate limiting**: Track API usage and implement throttling mechanisms.
- **Temporary data**: Store short-lived data like shopping carts or form data.

## Booking

The key-value store is implemented as an optional component on fortrabbit with various plans differing the available memory. It can be booked and scaled per [app environment](/1.platform/10.objects/2.app-environment.md). To book and scale the key-value store, navigate to the dashboard and select your app environment. Find the components section. Choose the key-value store and select the desired plan based on your memory requirements. Confirm your selection to book the key-value store.

## Scaling

Using a key-value store can contribute to better website performance. The component itself might also be scaled to further improve performance. As there are many different usage scenarios, there are no specific scaling recommendations. For most applications, the key-value store component will not hit critical limits. Thus autoscaling will not apply. When memory runs out, least recently used (LRU) keys are automatically removed to make space for new data.

- **Start small** and scale up based on your needs
- **Monitor memory usage** in the dashboard to understand your patterns
- **Test performance** at different scales to find the sweet spot
- **Scale up gradually** if you notice memory pressure
- **Consider usage patterns** - frequent writes need more memory than read-heavy workloads

## Using the key-value store

Valkey is supported by many PHP frameworks and CMS's out of the box, it's popular among [Laravel](/2.guides/2.laravel/1.setup.md) developers. For specific integrations check out the install guides and find out how to use it with your favorite framework or CMS.

### Session handler

If you don't use a framework, configure `session.save_handler` and `session.save_path` in your php.ini to tell phpvalkey where to store the sessions. Make sure to do it very early in your application, before accessing session data.

```php
// Read the secrects you've set in the Dashboard
$secrets = json_decode(file_get_contents($_SERVER["APP_SECRETS"]), true);
$host    = $secrets['CUSTOM']['VALKEY_HOST'];
$port    = $secrets['CUSTOM']['VALKEY_PORT'];
$auth    = $secrets['CUSTOM']['VALKEY_PASSWORD'];

// Change the session handler
ini_set('session.save_handler', 'valkey');
ini_set("session.save_path", "tcp://{$host}:{$port}?persistent=1&timeout=2&auth={$auth}");
```

### Persistent connections

We recommend using persistent connections. Most adapters are configurable with a setting like `persistent: 1`.

## Best practices

1. **Use meaningful key naming patterns** like `user:123:profile`
2. **Set appropriate expiration times** for temporary data
3. **Monitor memory usage** regularly
4. **Use persistent connections** to reduce overhead
5. **Implement proper error handling** for connection failures
6. **Test failover scenarios** in your application

## Related resources

- [Laravel Redis documentation](https://laravel.com/docs/redis)
- [Valkey documentation](https://valkey.io/docs/)
- [App environments](/1.platform/10.objects/2.app-environment.md)
- [Component scaling strategies](/1.platform/09.components/)
