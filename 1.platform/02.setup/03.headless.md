---
reviewed: 2025-04-29 10:57:31
title: Headless
naviTitle: Headless
navigation.excerpt: Reactive websites with PHP.
lead: Reactive websites with PHP.
siblings: Setup
nextNav: false
---

The hey days of jQuery are over. Modern Javascript frameworks are offering two-way reactive bindings. Web developers want that. But PHP is a server side language, that returns HTML after computation. It's not running in the browser. So it needs Javascript. What options are there to combine PHP and Javascript to create reactive websites?

This is a opinionated deep dive from my angle of the web. Some categories only exist in my head. But it helps me thinking about the subject, since we wan't to cover a lot of this with our [new hosting platform](https://new.fortrabbit.com).

## How to choose

This is not about winners and losers. This is about team size, requirements and most of it all personal preference and skills. Many developers stick to their home stack. That's it.

Some PHP developers tend towards backend development and try to avoid too much frontend work. Any abstractions is highly welcome? Don't need to leave PHP? Great! Others feels the need to control the border radius and the shade of blue.

## 1 - No reactivity

Check your premises. Do you really need a reactive website? Classical server side rendered websites are way less complicated to build, maintain and deploy. Server side rendered pages come with great SEO options out of the box. Specifically for small website projects, with smaller teams or even solo developers, consider carefully. Don't follow the latest trends without consideration. You may still add on-page JavaScript reactivty without querying the server.

## 2 - Decoupled

This dual stack approach consists of two independent system that can talk to each other. A frontend is based on Javascript (Svelte, Next.js, Nuxt.js, Astro â€¦). A PHP backend provides an API (REST, GraphQL). The frontend part is called JAMstack sometimes.

Traditional PHP CMS systems like WordPress bundle the backend and the frontend into one system. But a so called headless mode is now available for WordPress, Craft CMS and many more.

- <https://getkirby.com/docs/cookbook/headless/headless-getting-started>
- <https://craftcms.com/docs/getting-started-tutorial/more/graphql.html>
- <https://statamic.dev/rest-api>

PHP frameworks like Laravel and Symfony support API interfaces for a long time. The PHP backend system and the frontend system can live in separated code bases and can be developed and deployed independently. This makes it interesting for bigger teams or projects as well as frontend developers. The frontend website is just one client for the backend, another one might be a mobile app.

The use of Single Page Applications is a trend. Carefully consider if such a system is the best technology for the given project.

**Client Side Rendered (CSR)**: This is the classical Single Page App (SPA) style. The frontend consists of logic to render templates. All the data is provided by API to the frontend via AJAX calls. The website is constructed in the browser when a human visits. Not good if you want (SEO) bots to parse your content. Content is always up-to-date, using the latest data from the backend.

**Server Side Generated (SSG)**: During build time, usually during deployment, the whole content is pre-rendered as static HTML pages. The initial load will display the static page (fast), then the SPA mode will serve every click from them then on. This is good for SEO. But when the content in the backend changes, the frontend needs to de deployed again.

**Server Side Rendered (SSR):** This mode is able to do both, classical server side rendering and client side rendering. The drawback here is, that it requires a Node.js runtime on the server to query the backend for the latest content to return HTML directly to the browser. The content is always fresh and it is good for SEO. It might be slow.

There are plenty of additional strategies, like mixing the different methods together on a per-page basis or incrementally generating new content on intervals.

How to structure the code, setup local development and finally deploy to a public host?

**Monorepo:** the frontend and the backend code. This is easier to share and demo. The [Craft CMS Nuxt starter](https://github.com/craftcms/starter-nuxt) is a good example.

**Polyrepo:** Frontend and backend code are in different repos. For larger teams, separated code bases might be interesting.

## 3 - Coupled

Some developers questioned the decoupled approach. Why not send HTML? Why not use existing tooling for routing and authentication? Modern PHP frameworks come with battle tested tooling, like routing and authentication. Twig and Blade are powerful templating languages. Why abandon all that? Build modern monoliths!

### A - Livewire

The aim of Laravel Livewire is to enable PHP developers to create modern reactive websites without having to leave the PHP world at all. The logic is written in PHP, while the templates are still in Blade, but with superpowers to enable live partial updates and reactivity.

- <https://laravel-livewire.com/>

### B - Interia.js

Interia.js, also hailing from the Laravel scene, has a different approach. It glues together the PHP backend with any frontend, think Vue.js or React based systems. Unlike with decoupled systems, the data is directly provided by the PHP layer. Export data from PHP, directly use in Vue or alike. Each Javascript framework has it's own adaptor.

- <https://inertiajs.com/>

### C - Symfony UX

The user experience layer from Symfony is a mix of different technologies and boilerplate. It contains some ready made common use components for maps, icons and charts that can be directly used. It also includes the Hotwire (37signals) modules Turbo and Stimulus.

- <https://ux.symfony.com/>
- <https://hotwired.dev/>

## Deployment

It's assumed, that Git is used with Git provider such as GitHub, GitLab or Codeberg. How can the different options be put on public server in an automated way? This is a wide subject, let's focus on the requirements for the above mentioned reactive PHP projects.

### No reactivity

Easy peasy. This type does not require any complex interaction between frontend and backend and therefore is easy to deploy to a web host.

### Decoupled

For the decoupled project, the frontend and the backed projects can be deployed to different web hosts. Deploy the PHP part to service that supports a PHP runtime. Deploy the JS part to a dedicated JAMstack hosting service. This is sophisticated, but also a bit complex.

Depending on the project requirements and the service features, it might also be possible to deploy both projects to a single hosting service.

In most cases the frontend part needs to be built using something like `npm run build`. This is usually done during deployment. For example with GitHub Actions or a PaaS service that connects to the git repo.

### Coupled

Coupled projects need to be deployed alongside on the same server, since PHP will directly be involved. SSR or SSG?

<https://statamic.dev/javascript-frameworks>
**Pass all page data directly to a component**
