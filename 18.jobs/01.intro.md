---
reviewed: 2024-12-20 13:49:06
title: Jobs intro
navigation.excerpt: Background daemons and scheduled tasks
siblings: Components
lead: Background daemons and scheduled tasks.
# siblings: jobs
---

## Booking and scaling

Jobs is an optional [component](/11.concepts/components.md) that can be booked and scaled per [app environment](/10.objects/2.app-environment.md) in the [dashboard](/11.concepts/dashboard.md). The scaling increases in available RAM and number of jobs.

:DashboardLink{title="Book jobs for {{app-env-slug}}" path="/environments/{{app-env-slug}}/settings/components#workers-crons"}

## Creating jobs

After booking the component a new settings page will become available with the environment in the dashboard. Here you can add, remove, start, stop and edit jobs.

- **Status**: active/disabled
- **Job name**: A unique name, identifier
- **Command**: PHP command to run
- **Job type**: Cron or worker
- **Exit signal**: Graceful shutdown - default is usually fine
- **Exit timeout**: Time to forceful kill when graceful shutdown is not responding

### Cron settings

When choosing the type Cron these additional settings become available:

- **Interval**: How and when the job should run
- **Max runtime**: How long the job is allowed to run

Please also see our [cron primer article](/18.jobs/02.crons.md).

### Command settings

You need to call a command or script via the runtime. To call a PHP task you need to prefix it with `php`. To call a shell script you need to prefix it with `bash`:

- `php artisan queue:listen -v`
- `bash path/to/my-script.sh`

## Logging

You can access the jobs. Both STDOUT and STDERR generated by any job are logged.

## Restart after code update

This happens automatically. Whenever you push a new code update via [git deployment](/6.deployment/1.intro.md), jobs will be shutdown and started anew.

## Considerations

- The total (max) memory amount of all jobs should be below the memory limit of the plan.
- Exits of jobs should be looked into. Usually nonstop worker jobs should run continuously and not exist often.

The memory limit is for all jobs combined. Resources needed for each application can vary largely, depending on what each particular job is doing.

## Graceful shutdown

Say your job does really long running stuff or is very busy - meaning that it's likely that it is currently working when you push new code, which leads to a restart of the job. In this case, you might not want to abort (restart) it. The solution is to utilize Unix signal handling to write a shutdown handler. For this you can use the automatically available [PCNTL](http://php.net/manual/en/book.pcntl.php) extension.

The most simplistic PHP script for a job is a while loop:

```php
while (true) {
  do_something();
  sleep(5);
}
```

To make sure that `do_something()` is never aborted, you can extend the script like so:

```php
declare(ticks=1);

$shutdown = false;
pcntl_signal(SIGTERM, function($signo) use (&$shutdown) {
    error_log("Received shutdown signal");
    $shutdown = true;
});

while (true) {
  do_something();
  foreach (range(1, 5) as $num) {
    if ($shutdown) {
      error_log("Shutting down safely");
      exit(0);
    }
    sleep(1);
  }
}
```

## Do not detach

If you don't know what that is: never mind. If you do know: don't detach. To guarantee that we can monitor jobs correctly they need to run with-under the parent processes which started them. All detached processes will be killed.

## Overlapping jobs

Sometimes a job may be called multiple times and thus have multiple instances of the same job running. At best you should design your application that this is not happening or just within a controlled manner.

We apply reasonable limits to control how many jobs of the same type can be started at once.
